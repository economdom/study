# Работа с удалённым репозиторием GitHub

GitHub - не единственный удалённый сервер, но он является самым популярным и провереным.

GitHub не только предоставляет отличных хостинг для нашего Git репозитория, но и даёт другие полезные возможности, например графики и таблицы, которые показывают состояние различных бранчей, сделанные коммиты и графики активности.

## Настройка удалённого сервера на GitHub

Чтобы начать использовать GitHub нужно в начале завести там аккаунт.

Чтобы подключить новый репозиторий, нам сначала нужно его создать. Объязательным полем является только имя репозитория, описание же является не объязательным.

Сразу же после создания нового проекта, нам предлагается несколько полезных команд для начала работы с удалённым репозиторием. Например нам подсказуют как можно создать новый репозиторий, а затем сразу отправлять изменения на GitHub или как работать с удалённым репозиторием, в том случае если у вас уже создан локальный репозиторий.

Можно сразу же инициализировать репозиторий с файлом *README.md* и тогда будет создан первый коммит с этим файлом. Данный файл, созданный на языке Markdown автоматически загружает описание вашего проекта при открытии его на GitHub - фактически этот файл формирует стартовую страницу вашего проекта.

Также сразу же можно добавить файл *.gitignore*.

## Добавление удалённого репозитория

Перед началом ввода любых команд, убедитесь в том что вы находитесь в корне вашего проекта.

* `git remote` - данная команда выведет список всех удалённых репозиториев, которые она знает. Данная команда работает схожим образом что и `git branch`.
* `git remote -v` - отобразит список удалённых репозиторием и их URL, которые Git использует для извлечения и отправки данных в удалённый репозиторий. Обычно это одна и та же ссылка, но это не объязательно.
* `git remote add <alias> <url>` - добавит удалённый сервер. Нам нужно указать алияс и URL удалённого репозитория. После создания нового репозитория на GitHub, нам эти данные предоставляются автоматически, чтобы нам проще и быстрее можно было начать работу. По умолчанию генерируется алияс с именем `origin`, но мы можем назвать его как хотим. Опять же, это просто соглашение, что по умолчанию новый удалённый репозиторий мы называем `origin` - это просто рекомендованное имя.
* `git remote rm <alias>` - удалит удалённый репозиторий

```bash
git remote add origin https://github.com/kamuz/site.git
```

Таким образом будет создан новый удалённый репозиторий с именем `origin`, который указывает на удалённый сервер по предоставленному URL

Вы объязательно должны использовать свой GitHub аккаунт, чтобы вы могли работать с удалённым сервером, при этом URL у вас будут другими.

У вас может быть создано больше одного удалённого репозитория для вашего проекта и при этом все они будут/должны называтся по разному.

Все данные об удалённых репозиториях Git сохраняет в папке *.git/config/*

```bash
cat .git/config
```

Теперь наш локальный репозиторий знает об удалённом репозитории, который мы создали. Пока что мы не отправили туда никаких данных и в удалённом репозитории пока что нет наших бранчей, коммитов или чего-то подобного. На данным момент мы просто создали механизм, который может установить соединение, чтобы мы могли отправлять изменения в репозиторий.

Инспекция удаленного репозитория

```bash
$ git remote show origin
```

## Создание удалённого бранча

Теперь мы готовы отправлять наши коммиты в удалённый репозиторий, чтобы другие люди могли их видеть - этот процес называется `push`. Таким образом мы отправляем код на удалённый репозиторий, а точнее мы отправляем сам бранч.

* `git push -u <alias> <branch>` - отправить изменения на удалённый сервер

Для отправки локального бранча на удалённый нужно ввести

```bash
git push -u origin master
```

Таким образом на GitHub мы отправляем основной бранч `master`. 

Практически всегда указывают удалённый репозиторий `origin` и локальный репозиторий `master` потому что `origin` создаётся по умолчанию на GitHub при создании нового репозитория, а `master` это основной локальный бранч с которым делают слияние другие бранчи, если такие имеются.

После нажатия <kbd>Enter</kbd> нам нужно ввести логин и пароль от аккаунта на GitHub. В процессе отправки Git перечисляет имеющиеся объекты и сжимает их, так чтобы на GitHub был отправлен небольшой пакет данных, а затем он записывает объекты на другой стороне. Когда всё сделанно, Git создаёт для нас новый бранч.

После отправки данных Git нам сообщает, что основной бранч настроен так чтобы ослеживать удалённый основной бранч из `origin`. Для нас это делает опция `-u`.

Посмотрим что на самом деле было сделанно, как и много другое это сохраняется в папке `.git`.

```bash
cat .git/config
```

Как вы видите здесь есть определение бранча, а у бранча есть удалённое хранилище, а именно `origin`

```bash
[remote "origin"]
        url = https://github.com/kamuz/site.git
        fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
        remote = origin
        merge = refs/heads/master
```

Это позволяет указать Git куда нужно отправлять коммиты из основного бранча. Тоесть основной бранч `master` ссылается на `origin` (`remote = origin`), а `origin` в свою очередь ссылается на удалённый репозиторий (`url = https://github.com/kamuz/site.git`), а затем слияние даёт ссылку на то что будет использоватся, когда происходит слияние (`merge = refs/heads/master`).

Теперь давайте посмотрим куда Git сохраняет изменения.

* В папке *.git/refs/remotes* мы видим директорию *origin*
* Внутри папки *origin* есть наш бранч `master`
* Если мы заглянем внутри файла *.git/refs/remotes/origin/master*
* То мы увидим указатель `HEAD` который ссылается на верхушку основного бранча.

```bash
ls -al .git/refs/remotes
ls -al .git/refs/remotes/origin/
cat .git/refs/remotes/origin/master
git log --oneline -1
```

Всё работает так как и с обычными бранчами, просто всё хранится в отдельной папке *.git/refs/remotes*.

Обычно мы можем просмотреть бранчи при помощи команды `git branch`.

* Опция `-r` покажет удалённые бранчи
* Опция `-a` покажет и локальные и удалённые бранчи

```bash
git branch -r
git branch -a
```

## Клонирование репозиториев

Если вы захотите иметь локальную копию любого проекта на GitHub, если у вас есть желание развивать уже существующий проект тогда вам нужно склонировать удалённый репозиторий к себе на компьютер.

* Нужно скопировать путь к удалённому репозиторию. У нас есть два варианта HTTP или SSH, разницы никакой нет
* Используете команду `git clone`, после чего указываете скопиронный путь. По умолчанию будет создаватся новая папка внутри которой будут размещатся файлы и папки склонированного репозитория. Имя папки будет соответствовать имени репозитория на GitHub, но если вы хотите создать папку с другим именем, то для этого его нужно просто указать в конце, при этом имя папки не имеет ничего общего с именем репозитория. Когда мы выполняем клонирование, то Git также подсчитывает объекты и сжимает их и после этого мы получаем их локально

```bash
git clone https://github.com/rastating/pixel.js.git pixeljs.loc
```

Если мы зайдём внутри папки с проектом и введём `git branch`, то мы увидим только основной бранч `master`, потому что по умолчанию Git скачивает только этот бранч. Вы можете указать опцию `-b` и указать тот бранч, который вам нужен.

```bash
git clone https://github.com/rastating/pixel.js.git pixeljs.loc -b gh-pages
```

Кстати, можно также сделать настройку того какой бранч будет являтся бранчем по умолчанию в GitHub в настройках учётной записи.

## Отслеживание удалённого бранча

Ранее мы говорили о том как один локальный бранч синхронизируется с изменениями происходящие в другом бранче и этот процесс называется отслеживанием. Идея состоит в том чтобы оба этих бранча были синхронизированны. Таким образом мы периодически забираем изменения из основного бранча и отправляем их в другой бранч и таким образом они никогда сильно не отличаются и в случае необходимости всегда можем сделать слияние.

Отслеживание с удалёнными брачами работает схожим образом. В настройках можно указать Git какой удалённый бранч он должен использовать при извлечении и отправлении данных.

Опция `-u` во время выполнения команды `push` занимается отслеживанием и если её не указать, то Git не будет отслеживать никакой удалённый бранч и всё что он делает - это отправляет на удалённый репозиторий наш код.

В файле *.git/config* мы можем увидеть это отслеживание, тоесть сейчас у нас бранч `master` настроен так чтобы отслеживать `refs/heads/master` для `origin`

```bash
[branch "master"]
    remote = origin
    merge = refs/heads/master
```

* Создадим новый бранч `non_tracking`
* Запушим этот бранч на удалённый сервер
* Затем снова смотрим на *.git/config* и видим что и на данный момент этого бранча нет в списке

```bash
cat .git/config
```

Таким образом больше не будет никакого соеденения между нашим бранчем `non_tracking` и тем что происходит на GitHub. Опция `-u` помогла создать отслеживаемый бранч, но если когда-нибудь у вас будет бранч, который не отслеживается, а вы хотите чтобы он отслеживался, тогда у вас с есть три варианта:

* Можно использовать команду `git config`

```bash
git branch --set-upstream non_tracking origin/non_tracking
```

А можно ещё так

```bash
git branch --set-upstream-to=origin/master master
```

Или так

```bash
git config branch.non_tracking.remote origin
git config.branch.merge refs/heads/master
```

## Отправка изменений на удалённый репозиторий

* Делаем изменения в файле *index.html* и коммитим изменения
* Проверим изменения в основном бранче локального репозитория
* Проверим изменения в копии основного бранча удалённого репозитория и убеждаемся в том пока что последнего коммита здесь нет
* Можем сравнить эти два бранча
* Отравляем изменения на удалённый сервер. Можно указать полную версию, но можно котороче, тоесть без указания бранчей, так как у нас основной бранч добавлен в отслеживаемый, для этого можно просто указать `git push`

```bash
git commit -am "Add new attribute to link into index.html"
git log --oneline -3
git log --oneline origin/master -3
git diff master..origin/master
git push origin master
```

Теперь если мы проверим снова логи или зайдём на GitHub, то мы увидим что все изменения уже имеются в удалённом репозитории.

## Извлечение данных из удалённого репозитория

Если у нас есть несколько пользователей, то нужно чтобы все локальные репозитории всех пользователей были синхронизированные между собой, тоесть каждый пользователь должен иметь возможность забирать последние изменения из удалённого центрального репозитория. Извелечение, тоесть команда `fetch` это то что синхронизирует бранч `origin/master` с тем что имеется на удалённом репозитории и `origin/master` автоматически не отображает то что есть в удалённом репозитории - мы должны сказать Git что нам нужно синхронизировать оба репозитория. 

Тоесть когда мы выполняем команду:

```bash
git log --oneline -3 origin/master
```

Тоесть смотрели логи `origin/master`, то на самом деле Git не пошёл на GitHub чтобы посмотреть эти данные - он просматривал локальную копию, с того времени, когда вы последний раз делали синхронизацию, тоесть с того времени когда мы делали извлечение данных из удалённого репозитория и в нашем случае это было тогда, когда мы сделали клонирование репозитория. Эта команда может быть сделана даже тогда, когда у вас нет подключения к интернет и не нам не нужно иметь доступ к GitHub чтобы получить информацию об `origin/master`, но мы не получим самую последную информацию - мы получим ту информацию, которая была последней, когда мы синхронизировали хранилище, но когда мы прописываем `git fetch` Git идёт на GitHub и забирает информацию из удалённого репозитория, но чтобы сделать это, ему уже нужно интернет-соединение.

После команды `git fetch` нужно указать что именно мы хотим извлечь - мы хотим перейти в `origin`, в данном случае это GitHub. Поскольку у нас только один удалённый репозиторий, то мы можем просто прописать `git fetch`

* Загрузим изменения из удалённого репозитория в локальный
* Теперь проверим логи в `origin/master` и видим что изменения загруженны в наш локальный репозиторий. Теперь репозиторий `origin/master` синхронизирован с удалённым репозиторием

```bash
git fetch
git log --oneline origin/master -3
```

Таким образом когда мы прописываем `git fetch` происходит синхронизация с удалённым репозиторием, Git забирает все объекты, которые там есть и скачивает ярлыки, которые указывают на верхушки каждого находящеегося в удалённом хранилище.

Если мы посмотрим логи для основного бранча, а не для `origin/master`, то вы увидите что последнего коммита здесь ещё нет, тоесть мы не перенесли изменения в основной бранч и нам нужно сделать слияние. Git перенёс изменения только в `origin/master` который всегда пытается синхронизироватся с удалённым репозиторием - это просто кэшированная версия нашего удалённого репозитория.

Вообще важно отметить, что когда мы синхронизируемся с удалённым репозиторием при помощи `fetch` мы просто обновляем `origin/master`, а основной бранч вообще не меняется. Таким образом, получается что команда `fetch` совершенно безвредна и её можно использовать достаточно часто.

* Всегда делайте `fetch` прежде чем начать работу
* Прописывайте `fetch` прежде чем прописать `push`. Прежде чем отправить свои коммиты, посмотрите что уже есть в удалённом репозитории. Возможно кто-то другой уже отправил подобный коммит или возможно уже кто-то отправил такие изменения, которые могут конфликтовать с вашими
* Прописывайте `fetch` часто. Эта команда ничего не разрушает, поскольку данная команда не вносит автоматически никаких изменений в основной бранч, но мы хотим их иметь, тогда нам нужно сделать их самим выполнив слияние.

## Слияние извлечённых изменений

После извлечения данных из удалённого репозитория они ещё не добавленны в основной репозиторий, а пока только в `origin/master` и для того чтобы добавить эти изменения в основной бранч нужно сделать слияние.

`origin/master` это просто бранч, как и все другие бранчи, а также это удалённый бранч и это единственное, что отличает его от других бранчей с которыми мы обычно работаем, тоесть мы не можем сделать его `checkout`, а в остальном всё одно и то же.

В том что мы не можем сделать его чекаут есть смысл, потому что Git должен иметь возможность синхронизировать его с тем, что есть в удалённом хранилище, поэтому чекаут для него не приемлен. Если мы сделаем `checkout`, тогда мы сможем внести туда коммит и это всё запутает. Вместо этого у нас есть другие бранчи, с которыми мы работаем, а Git следит за `origin/master` чтобы он отражал то что находится в удалённом хранилище. Но кроме того факта, что мы не можем сделать чекаут, он такой же как и все остальные бранчи.

* Отобразим все бранчи
* Посмотрим изменения в основном бранче и `origin/master`
* Сделаем быстрое слияние
* Проверим есть ли теперь последний коммит в основном бранче

```bash
git branch -a
git diff master..origin/master
git merge origin/master
git log --oneline -3
```

Команды `git fetch` и `git merge` это команды которые должны идти одна за другой при работе с удалённым репозиторием.

`git pull` - это эквивалент-сокращение для `git fetch` + `git merge`, тоесть, с помощью `git pull` мы выполняем извлечение и слияние за один шаг.

## Чекаут удалённых бранчей

Если мы перейдём в тот проект, который склонирование с удалённого репозитория и который является копией вашего локального репозитория и проверим там бранчи, то мы увидим что у нас есть единственный локальный основной бранч `master` и два удалённых `origin/master`, `origin/non_tracking`.

```bash
git branch
git branch -r
```

Теперь мы хотим иметь возможность работать с бранчем `non_tracking`. Ранее, говорилось о том что удалённые точно такие же как и удалённые, но для них нельзя сделать чекаут. Это имеет смысл, потому что Git контролирует этот удалённый бранч, так что он знает, что всегда синхронизирован с тем что есть в удалённом репозитории, но он не хочет чтобы мы делали то же самое. Но посколько удалённый бранч, это по сути обычный бранч, то мы можем создать из него обычный бранч и работать с ним.

Нам нужно указать от куда должен новый бранч должен брать информацию и ранее мы указывали на верхушку текущего бранча, примерно так:

```bash
git branch new_branch HEAD
```

Но в качестве источника можно также указать конкретный коммит или другой бранч, например мы будем использовать `origin/non_tracking`.

```bash
git branch non_tracking origin/non_tracking
```

Таким образом только что созданный бранч `non_tracking` будет настроен так чтобы отслеживать изменения сделанные в удалёном бранче `origin/non_tracking`.

Теперь если посмотрить в файл `.git/config`, то вы увидите что `non_tracking` настроен так что отслеживать `origin/non_tracking`.

```bash
cat .git/config
```

Теперь давайте удалим этот бранч.

```bash
git branch -d non_tracking
```

Это не имеет ничего общего что происходит в удалённом репозитории, ничего общего с тем что происходит в `origin/master` - они всё ещё на месте.

Можно написать

```bash
git checkout -b non_tracking origin/non_tracking
git branch
```

И это создаст бранч и сделаем его чекаут (переход в этот бранч) - всё за один шаг.

Теперь мы можем делат сюда коммиты, а затем когда мы отправим их в удалённый репозиторий, они попадут в удалённый бранч `non_tracking`.

## Отправка и обновление изменений на удалённом бранче

Поговорим о том что может произойти, когда вы попытаетесь отправить изменения в удалённый репозиторий в котором уже есть другие изменения. Допустим у нас есть удалённый сервер и локальный репозиторий и в каждом из них есть 3 коммита. Мы пишим `fetch` и тогда они полностью синхронизированны. Через час вы сделали новый коммит в локальный репозиторий и готовы отправить изменения на удалённый сервер, но к этом времени другие разработчики также сделали изменения и отправили их в удалённый репозиторий. Теперь когда мы захотим отправить свои коммиты, удалённый сервер скажет нам что не знает, что ему делать с вашими коммитами, потому что в это время появились новые изменения. Git никогда не попытается сделать слияние вместо отправки данных, а вместо этого Git скажет, что была добавленна новая информация и он не знает что ему делать. Вам нужно забрать изменения, которые находятся на удалённом сервере, отсортировать их со своей стороны и попробовать снова.

Итак, мы пишем `fetch` и теперь у нас есть коммиты с удалённого сервера и теперь нам нужно сделать слияние с помощью `merge` и тогда новые изменения попадут в `origin/master`, будет создан новый коммит слияния и затем мы снова можем отправить наши изменения на удалённый сервер и теперь он их примет. Если бы у нас возник конфликт при слиянии, то нам бы пришлось его разрешить, но обычно их не возникает.

Запомните, если вы не можете отправить данные на удалённый сервер, то вам нужно просто прописать `fetch`, затем `merge`, а затем снова `push`.

## Удаление бранча на удалённом сервере

Есть два способа

* Использовать `git push` и чтобы удалить бранч нужно перед названием бранча указать двоеточие.

```bash
git push origin :non_tracking
```

Git нам сообщает что бранч удалён и мы можем это проверить на GitHub. Удалится только бранч `origin` при этом локальный бранч не будет удалён.

На самом деле это сокращение от:

```bash
git push origin non_tracking:non_tracking
```

Эта запись говорит отправить локальный бранч `non_tracking` в удалённый бранч `non_tracking`. В том случае, если у нас только один бранч Git посчитает их одинаковыми и за частую оно так и есть. Но это двоеточие разделяет два бранча. И когда мы удаляем бранч таким образом, тоесть:

```bash
git push origin :non_tracking
```

То на самом деле мы говорим что в удалённый бранч `non_tracking` не нужно ничего отправлять, вот из за чего там стоит двоеточие. Но этот способ не очень интуитивен, но есть другой способ.

* Для начала отправим наш локальный бранч на удалённый сервер
* Удалим этот бранч с использованием опции `--delete`

```bash
git push origin non_tracking
git push origin --delete non_tracking
```

Эту команду дольше набирать, но её проще запомнить и она является более интуитивно понятной.

Удаление удаленного репозитория - попросту отключение от него - в примере от `origin`.

```bash
git remote rm origin
```

## Переименование удаленных репозиториев

По существу переименование локальной ссылки на удаленный репозиторий

```bash
git remote rename <old_name> <new_name>
git remote rename tr newtr
```

## Совместная работа

Здесь речь пойдёт о том как вы можете добавить сотрудников в свой проект и как вы сами можете присоеденится к проекту с открытым исходным кодом.

Пока что мы работали с одного аккаута GitHub, но при работе с несколькими людьми вам нужно настроить совместный доступ к проекту. Для этого нужно зайти в настройки проекта в раздел совместной работы - *Settings / Collaborators*. Нужно ввести полное имя пользователя, логин или адрес электронной почты пользователя GitHub. При этом на адрес электронной почты данного пользователя прийдёт приглашение поучаствовать в проекте с ссылкой для клонирования проекта. У этого пользователя появляется возможность и читать изменения и вносить их.

При работе над проектом с открытым исходным кодом, было бы не правильно, если бы каждый пользователь мог вносить изменения в существующий проект, но при этом просматривать коммиты должен иметь каждый пользователь.

Перед тем как вносить изменения нужно сделать форк, но перед тем нужно убедится в том что кто-то другой не работает в том же направлении - возможно уже кто-то предложил эту идею, уже идёт обсуждение или работа, и поэтому особо нет смысла дублировать чью-ту работу.

Хорошая практика заключается в том чтобы отправить сюда задачу того что вы хотите сделать и чтобы другие люди это видели. Тогда можно сделать свою развилку (`fork`) проекта и тогда у вас будет своя версия этого проекта в вашем GitHub репозитории. Это уже больше не часть основного проекта и поэтому сюда вы уже можете вносить изменения, далее вы клонируете репозиторий и работате с ним локально как обычно, коммитите изменения в свою версию проекта, а когда уже всё сделанно, то вы возвращаетесь на основную страницу проекта GitHub и для этой задачи отправляете `pull request`. С этим запросов вы отправляете сообщение, где вы определяете увиденную проблему или новый функционал, который бы вы хотели бы добавить и говорите о том почему это должно быть хорошо для этого проекта и если очевидность этого шага и ваш код выглядит хорошо, тогда ваши изменения будут приняты и включенны в основной проект, ваш бранч будет скачан и произойдёт слияние. Таким образом возможна совместная работа в Git.

## Клонирование отдельный веток удалённого репозитория

По умолчанию всегда клонируется только ветка `master` из удалённого репозитория.

* Мы можем просмотреть какие есть удалённые бранчи с помощью опции `-a`
* Нам нужно создать локальный бранч и мы можем сразу же в него переключится и указать источник (удалённый бранч), с которого будут отслеживатся изменения с помощью команды `git checkout`

```bash
git branch -a
git checkout -b non_tracking origin/non_tracking
```

Таким образом мы говорим, что мы хотим создать новый бранч и тут же переключится в него, который бы копией бранча на удалённом сервере.

Чтобы клонировать содержимое репозитория в уже созданную папку можно воспользоватся такой командой.

```bash
git clone --mirror https://github.com/planetoftheweb/responsivebootstrap.git .git
```

Таким образом мы не клонируем весь проект, а только репозиторий Git, тоесть папку *.git*

```bash
git config --bool core.bare false
git reset --hard
```

`git config --bool` сообщает Git о том что будет использоватся логическое значение в конфигурации. Если клонировать репозиторий таким образом, то у нас `core.bare true`, тоесть у нас голый (*анг.* base) репозиторий, тоесть в этом репозитории ничего нет, кроме служебной/скрытой папки *.git*. `core.bare false` переключает с пустого репозитория на обычный.

`git reset --hard` позволит захватить всё что есть внутри папки *.git*, а затем создать все бранчи с файлами проекта, как в обычном репозитории.

А таким образом мы востановим состояние файлов во время последнего коммита.

## Рабочий процесс совместной работы

Предположим что мы знаем этот проект, а сегодня я захожу сюда чтобы реализовать необходимый функционал.

* Вам нужно перейтив в основной бранч, чтобы начать работу
* Перед началом работы нужно всегда сделать выгрузку последних изменений из основного бранча на удалённом сервере. Мы должны выяснить какие новые коммиты были сделанны за последнее время
* После этого оказывается что на данный момент кто-то из наших колег уже внёс какие-то изменения, но они не связанны с тем функционалом, которые я хочу добавить, но всё таки я должен быть уверенным что эти изменения у меня имеются
* Далее я хочу внести изменения находящиеся в `origin/master` в мой бранч `master`
* На данный момент я полностью синхронизирован с тем что находится в удалённом репозитории и мы готовы разрабатывать новый функционал, но делать это нужно в отдельно бранче и поэтому ваша работа не навредит тому что находится в основном бранче. А если затем, по какой-то причине, вы не захотите продолжить разработку функционала, то бранч можно легко удалить. Создадим и переключимся в новый бранч `feed_backform`.
* Вносим изменения в рабочую директорию, добавляем их индекс и коммитим изменения
* Прежде чем отправлять изменения на удалённый сервер, нужно проверить если в репозитории изменения, которые мне нужно принять во внимание. Если такие изменения есть, то мы решаем нужно ли вносить в бранч `feedback_form` или нет
* Далее мы можем отправить весь бранч в `origin`, а не только отдельный коммит. Новый бранч не существует на удалённом сервере до тех пор, пока ты не отправим его туда. Опция `-u` делаем бранч отслеживаемым, что позволит нам писать меньше команд, но при это Git сам уже будет знать куда отправлять изменения.
* Когда вся работа сделано, то моя работа попадает в удалённый репозиторий и мои колеги могут её видеть.

После этого мы может отправить email другим разработчикам и сказать чтобы они оценили проделанную работу.

```bash
git checkout master
git fetch
git merge origin/master
git checkout -b feed_backform
git add feedback.html
git commit -m "Add customer feedback form"
git fetch
git push -u origin feedback_form
```

Теперь мы посмотрим возможные действия наших коллег

* Перед началом работы нужно перейти в основной бранч
* Затем следует извлечь изменения из удалённого сервера. Если этого не сделать, то даже не будет видет ваш новый бранч, возможно другие учасники проекта также сделали изменения за это время
* Возможно вы также захотите перенести изменения в свой основной бранч, чтобы он всегда был полностью обновлён. В этом не особой необходимости, но это хорошая практика
* Далее нужно сделать чекаут бранча, который мы туда отправили. В этот раз опция `-b` мы не просто запрашиваем бранч `feedback_form`, что не просто выведет нас из бранча в котором мы находились, а вместо этого мы заправшиваем `feedback_form` и его источник, а это `origin/feedback_form`, то что мы отправили на удалённый сервер. Также это уже будет отслеживаемый бранч и наши сотрудники будут видеть наши изменения.
* Мы можем использовать `git log` и найти требуемый коммит, который мы добавили
* Также мы можем просмотреть этот коммит для чего можем использовать SHA или `HEAD`, если это был последний коммит
* После того, как ваши сотрудники посмотрели сделанные вами изменения они могут их закомитить
* Проверяем не появились ли за это время новые изменения
* Отправляем полученные от нас изменения на удалённый сервер

```bash
git checkout master
git fetch
git merge origin/master
git checkout -b feedback_form origin/feedback_form
git log
git show 84b6adf0
git commit -am "Add tour selector to feedback form"
git fetch
git push
```

Когда наши сотрудники внесли наши изменения в основной бранч на удалённом сервере, мы можем посмотреть что получилось в итоге

* В началае нужно забрать последние изменения с сервера
* Прежде чем сделать слияние нам нужно посмотреть логи чтобы понимать что произошло. Мы используем опцию `-p` и нам будут показаны все записи логов, а также суть изменений, которые касаются конкретной записи
* Если есть разница и изменения, сделанные моими коллегами меня устраивают, то я могу сделать слияние
* Переключаемся в основной бранч
* Снова получаем последние изменения с удалённого сервера
* Делаем слияние нашего основного бранча и бранча на удалённом сервере
* Прежде чем следать следующий шаг нужно точно убедится в том что, наш бран полностью обновлён. Этот шаг заключается в том чтобы забрать изменения из `feedback_form`, после чего отправляю его в основной бранч
* Мы забрали изменения из `feedback_form`, но также мы могли их забрать с `origin/feedback_form`, они оба указывают на один и после того как мы сделали слияние, мы предотватили появление каких-либо конфликтов при слиянии
* Пушим изменения и после чего наша работа находится на удалённом сервере в основном бранче, где её могут увидеть все люди, которые работают над проектом

```bash
git fetch
git log -p feedback_form..origin/feedback_form
git merge origin/feedback_form
git checkout master
git fetch
git merge origin/master
git merge feedback_form
git push
```

Это базовый процесс, который будет повторятся от проекта к проекту и со временем вы его легко запомните и будет применять в своей практике.

## Использование бранча проекта на GitHub в качестве шаблона

* Для того чтобы клонировать отдельный бранч можно использовать опцию `-b` и название бранча.
* Проверим коммиты в данном бранче
* Удалим папку *.git*
* Если мы попробуем проверить логи, то нам скажут что это не Git репозиторий
* Теперь мы можем инициализировать здесь репозиторий и использовать его как шаблон

```bash
git clone -b 00_start https://github.com/planetoftheweb/responsivebootstrap.git bootstrap.io
git log --oneline
rm -dfr .git
git log
git init
git log
git .
git commit -m "First commit"
git log
```

Таким образом у нас мы создали шаблон из определённого бранча Git репозитория.

# Работа с пулл реквестами

Запрос на включение или `pull request` позволяют вам рассказать другим о тех изменениях, которые вы разместили в своём GitHub-репозитории. Как только `pull request` отправлен, заинтересованные стороны рассматривают ваши изменения, обсуждают возможные правки или добавляют ваши изменения. Посылая `pull request`, вы говорите автору изначального репозитория - смотри, что я сделал, можешь ли принять мои изменения и влить их в проект?.

На GitHub популярны две модели совместной разработки:

* Модель `fork + pull` позволяет любому склонировать (fork) существующий репозиторий и сливать изменения в свой личный fork без необходимости иметь доступ к оригинальному репозиторию. Затем, изменения должны быть включены в исходный репозиторий его хозяином. Эта модель уменьшает количество телодвижений для новых contributors и популярна для open source проектов, так как позволяет людям работать независимо, без единого координирования.
* Модель общего репозитория (*англ.* The Shared Repository Model) чаще встречается у малых команд и организаций, работающих над закрытыми проектами. Каждый в команде имеет доступ на запись в один общий репозиторий, а для изолирования изменений применяются тематические ветви (*англ.* topic branches).

Pull request'ы особенно полезны в модели «Fork + Pull», поскольку предоставляют способ уведомить мэйнтэйнеров проекта (т.е. хозяина оригинального репозитория) о изменениях в вашей копии репозитория. Впрочем, они так же полезны и в модели общего репозитория, где обычно используются для того, чтобы инициировать пересмотр или обсуждение кода перед тем, как включать его в основную ветвь разработки.

Без кода это выглядит так

* Другой разработчик создал репозиторий
* Вы сделали форк его репозитория (т.е. скопировали к себе)
* Вы сделали какие то изменения в своём репозитории.
* Теперь если вы хотите, чтобы другой разработчик внёс ваши изменения в свой код, вы просите, что бы он взял ваши изменения, т.е. сделал `git pull`. Это и называется `pull request`

А так более наглядно на примере

* Форкаете репозиторий
* Клонируете репозиторий к себе на компьютер
* Переходите в папку с проектом
* Добавляем псевдоним `upstream` для оригинального репозитория, мы не можем добавлять в него изменения, но можем их получать

```
git https://github.com/username/packagename
cd packagename
git remote add upstream https://github.com/main/packagename
git checkout -b datenstrom/packagename
```

Теперь вы правите файлы в вашем `origin`, в вашей ветке, пушите их в свой форк GitHub (`origin`), откуда и делаете `pull-request`.

При этом вы можете сделать `git merge/pull/fetch upstream` с оригинального репозитория (`upstream`).

## 01 Делаем копию репозитория

На странице репозитория имеется кнопочка **Fork**, которую и следует нажать.

После чего, эту копию можно клонировать на свой компьютер:

```bash
git clone git@github.com:username/reponame.git
```

Склонированный репозиторий имеет одну привязку к удалённому репозиторию, названную origin, которая указывает на вашу копию на GitHub, а не на оригинальный репозиторий, чтобы отслеживать изменения и в нём, вам нужно будет добавить другую привязку, названную, например, `upstream`.

```bash
cd reponame
git remote add upstream git://github.com/username/reponame.git
git fetch upstream
```

## 02 Делаем работу

В этой точке мы уже можем править код и делать коммиты. Рекомендуется делать всю работу в отдельной тематической ветви разработки. Полезность этого станет ясна на этапе посылки `pull request`. Пускай она будет называться `feature`.

* Создадим новую ветвь `feature` и делает её активной

```bash
git checkout -b feature
```

Как только вы сделали работу, отправьте её в свою копию репозитория на GitHub

* Загружаем изменения в текущей ветви в origin в ветвь feature

```bash
git push origin feature
```

## Возвращаем изменения

Вы написали код, он у вас в ветви `feature` как у вас на компьютере, так и на GitHub. Осталось только отправить его в оригинальный репозиторий.

Переходим на страницу вашей копии репозитория на GitHub, выбираем ветвь `feature` и жмём кнопку **Pull Request**.

Далее вы попадёте на предпросмотровую страницу, на которой сможете ввести название и описание ваших изменений (название потом попадёт в описание мёрдж-коммита и станет достоянием общественности).

Там же вы можете посмотреть, какие коммиты попали в пулл реквест, а так же общий diff всех изменений в пулл реквесте

Дальше следите за вашим пулл-реквестом. Что прокомментируют люди, что скажет мэйнтэйнер, примет или нет ваш пулл реквест.

Рекомендуется все изменения, которые пойдут в пулл, держать в отдельной ветке, потому что вы всегда можете добавить коммиты к уже существующему пулл реквесту, просто добавив их к этой ветке в вашем репозитории.


Когда ваш pull request примут, не забудьте слить изменения в свой репозиторий

```bash
git checkout master
git pull upstream master
git push origin master
```

Если работа заняла большое время и оригинальный репозиторий успел уйти вперёд, то можно просто влить изменения из оригинального репозитория к себе:

```bash
git checkout master
git pull upstream master
git checkout feature
git merge master
```

Однако хозяину оригинального репозитория или, может быть, даже вам, не понравится наличие мёрж-коммитов и коммитов из master'а в списке коммитов на пулл. В таком случае вам стоит воспользоваться git rebase.

git checkout master
git pull upstream master
git checkout feature
git rebase master #Всё отличие только здесь


Прочитать про то, как работает rebase можно в официальном руководстве. Там имеются и очень понятные иллюстрации. Так же есть статья в помощи GitHub.
ВНИМАНИЕ: Пожалуйста, учтите, что git rebase меняет id коммитов! Поэтому, все действия с этой командой стоит выполнять только на локальном репозитории, до того, как эти коммиты станут общедоступны, т.е. до того, как вы их push'нули на гитхаб.

Если вы хозяин: Как принять pull request

Если пулл реквест удовлетворяет всем условиям, то кто-либо с правом «на запись» (т.е. может сделать push) в целевой репозиторий, должен принять pull request одним из многих методов. Ниже описаны три наиболее популярных метода: 

Auto Merge (автослияние)

Во многих случаях можно попросить github автоматически принять пулл реквест, используя большую зелёную кнопку Merge Pull Request, которая сама вольёт изменения, создаст мёрж-коммит и закроет пулл реквест.
Кнопка автослияния
Подробнее можно почитать в этом хабратопике: Кнопка слияния на GitHub.

Fetch and Merge (скачать и слить)

Основной метод вливания изменений. Он требует добавления remote, ведущего к репозиторию человека, отправившего pull request, скачивания изменений с этого репозитория, объединения нужной ветви, исправления конфликтов и выгрузки обновлённой ветви обратно в исходный репозиторий:
git checkout master
git remote add username git://github.com/username/Spoon-Knife.git
git fetch username
git merge username/feature
git push origin master


Patch and Apply (пропатчить и принять)

Предыдущий метод работает хорошо, когда вы работаете в команде или постоянно принимаете изменения от одной и той же группы людей. Другой метод немного быстрее в единичных случаях при использовании git-am.

У каждого пулл реквеста есть свой .patch URL, с которого можно скачать текстовый патч, чтобы скормить его команде git-am:
git checkout master
curl https://github.com/octocat/Spoon-Knife/pull/50.patch | git am
git push origin master


Закрытие пулл реквеста

Запросы на пулл автоматически закрываются, когда запрошенные коммиты вливаются в репозиторий назначения. При этом генерируется событие, информирующее всех участников разработки, что пулл реквест был принят и влит в основную ветвь.
Событие закрытия пулл реквеста
Так же возможно вручную закрыть пулл реквест в случае, если он был отклонён. Иногда это необходимо в случаях, когда изменения были приняты с помощью git-cherry-pick или другого механизма, который не позволяет обнаружить факт слияния (merge).

## Пример для MODX Revolution

В первую очередь, заходим на страничку нужного нам репозитория и нажимаем кнопку Fork. Теперь у вас есть своя версия этого дополнения)

Теперь нам нужно исходный код дополнения выгрузить на сайт, чтобы мы могли его изменять и тут же проверять. Открываем терминал (подключаемся к нашему серверу по SSH) и переходим в папку сайта:

```bash
cd modextra.site.ru/public_html/
```

И в этой папке выполняем следующую команду:

```bash
git clone https://github.com/username/name_package
```

Теперь нам надо сгенерировать пакет для установки, чтобы проверять результат - для этого нужно открыть [http://sitename.ru/name_package/_build/build.transport.php](http://sitename.ru/name_package/_build/build.transport.php).

Вносим изменения, проверяем работоспособность, изменяем версию в файле */_build/build.transport.php* и пишем changelog в файле */core/components/need_package/docs/changelog.txt*

Коммитим и пушим изменения на свой репозиторий, и после этого создаем и отправляем пулл-реквест. Затем этого ждем ответа от разработчика.