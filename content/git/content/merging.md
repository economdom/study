# Слияние бранчей

Теперь вы умеете создавать новые бранчи и использовать их для проверить новые идеи и реализовать новые возможности. А что если всё получилось, что если идея оказалась успешной и какая-то новая возможность реализована и теперь вы хотите внести эти изменения в `master` бранч для того чтобы они стали частью основного проекта. Чтобы это осуществить нужно сделать слияние, а именно как перенести эти изменения и корректно сделать слияния одного бранча с другим.

Если вы не помните какие именно изменени были сделанны можно написать.

```bash
git diff master..seo_title
```

Теперь нам нужно перенести сделанные изменения в `seo_title` в бранч `master`.

* Нам нужно убедится что мы сделали чекаут/переключение бранча куда мы переносим изменения

```bash
git branch
git checkout master
```

* Уже из `master` бранча мы прописываем команду `merge` и передаём имя бранча, с которым нужно произвести слияние, тоесть нужно указать ту ветку с которой будут приняты изменения.

```bash
git merge seo_title
```

Затем Git предоставляет сводку того что произошло и предоставляет ссылку на сводку сделанных изменений.

* Теперь можем проверить что разницы между этими двумя ветками никакой нет

```bash
git diff master..seo_title
```

Если мы посмотрим на логи, то мы увидим что все изменения на месте.

Посмотрим включают ли изменения из `seo_title` в бранче `master`.

```bash
git branch --merged
```

Как видим что бранч `seo_title` полностью включён в основной бранч. Если бы захотели, то мы могли бы полностью удалить бранч `seo_title`.

Слияние может быть сложным, слияние может быть трудным и мы рассмотрим что можно сделать в таких ситуациях в следующих уроках. Поэтому `git merge` всегда делается из чистой рабочей директории - когда нет незакоммиченых изменений и вы можете их спрятать, вы можете обратить их в коммиты, но рабочая директория должна чиста и тогда у вас будет чистое рабочее пространство, где вы можете решить проблемы со слиянием.

## Разница между быстрым слиянием и реальным слиянием

Как правило слияние делается при помощи нового коммита, но ранее мы этого не делали. Причина в том что там не было представленно состояние бранчей на тот момент - мы до сих пор ещё не сделали изменений в основном бранче. Мы создали бранч, затем мы сделали один коммит в этот бранч, но мы не сделали никаких изменений и как результат у нас получилось быстрое слияние. После выполнение слияния, Git нам сообщил какое именно он сделал слияние - в нашем случае это быстрое слияние (`Fast-forwart`).

Что же происходит когда Git собирается сделать слияние? Он берёт всё то что у вас есть, начиная с конца и берёт всех предков, а затем возвращается к самому началу. Попутно он смотрит есть ли у него указатель `HEAD` текущего основного бранча. В нашем случае `HEAD` указывал на коммит, где был сделан бранч и не было сделанно никакого перемещения. Если Git увидит в такой цепочке `HEAD`, то он спокойно может сделать быстрое слияние, тоесть нам не нужно делать слияние и при этом создавать новый коммит, а вместо этого мы можем просто переместить новый коммит вверх по цепочке и после этого переместить на него `HEAD`. После такого слияния оба брача будут указывать на один и тот же коммит и при этом нет никакой необходимости делать новый коммит - нужно просто пройти по цепочке и сделать быстрое слияние.

Если мы проверим логи обоих бранчей, а именно 3 последних коммита, по котором происходило быстрое слияние, то мы увидим одни и те же изменения.

```bash
git log seo_title --oneline -3
git log master --oneline -3
```

Как мы видим это один и тот же объект сохранённый в Git и в данном случае Git не делает новый коммит, он делает быстрое слияние.

Есть также несколько опций, связанных с быстрым слиянием:

* `git merge --no-ff name_branch` - заставляет Git создать коммит слияния, она говорит не делай быстрого слияния и создай новый коммит с сообщением. Это стоит делать в том случае, если вы хотите получить задокументированное подтверждение того что вы провели слияние, тоесть вам нужно получить логи этого действия
* `git merge --ff-only branch` - сделать слияние только в том случае, если оно будет быстрым. Если вы не можете сделать быстрое слияние, тогда процесс просто оборвётся.

Теперь в качестве примера давайте сделаем реальное или не быстрое слияние. Давайте посмотрим на наши бранчи. Пока что у нас бранчи `seo_title` и `master` имеют одинаковые изменения. Теперь нужно объеденить изменения из `shorten_title` с основным бранчем `master`.

Если бы мы сделали слияние как и раньше, то произошло бы быстрое слияние. Так происходит потому что единственное отличие между бранчами заключается в том что в `shorten_title` есть коммит, которого нет в основном бранче. Сначала было два коммита, но теперь один коммит уже имеется в основном бранче (мы делали слияние), так что будет произведенно быстрое слияние. Вместо этого мы не хотим делать быстрое слияние и вместо этого нам нужно отправить ещё один коммит в основной бранч, тоесть если в основном бранче появится коммит, тогда Git не сможет сделать быстрое слияние, потому что `HEAD` переместится на новый коммит, который не находится в бранче `shorten_title`.

* Убедитесь что вы находитесь в основном бранче, а теперь можете сделать изменения в прокте и закоммитить их.

```bash
git branch
vim index.html
git status
git commit -am "Delete one item of list"
```

* Проверим что не все изменения которые есть в `master` присутствуют в `shorten_title`. По этой причине мы не сможем сделать быстрое слияние.

```bash
git log --oneline -3
git log shorten_title --oneline -3
```

Так как сейчас `HEAD` указывает на последний коммит в бранче `master`, которого нет в бранче `shorten_title`, тоесть последний коммит не является предком `shorten_title`, поэтому у нас не получится выполнить быстрое слияние, но теперь мы выполним реальное/настоящее слияние. Процесс абсолютно такой же - мы просто переписываем изменения из `shorten_title` в основной бранч, но теперь Git попросит написать нам сообщение для коммита в текстовом редакторе по умолчанию (в моём случае это Vim). По умолчанию Git уже генерирует шаблонное сообщение для коммита в подобных ситуациях, но если оно вас не устраивает, то вы можете его переписать.

```bash
git merge shorten_title
```

 После того как вы указали сообщение и закрыли редактор, процесс слияния завершится и вы получити сообщение `Merge made by the 'recursive' strategy`.

 Есть разные стратегии для слияния и рекурсивная - это та, которую вы зачастую будете видеть в Git. Git выясняет как сделать слияние двух бранчей и если сейчас вы посмотрите на логи, то вы увидите новый коммит с сообщением, которое сгенерировал сам Git - `Merge branch 'shorten_title'` и это коммит, который связывает эти два элемента.

 Иногда при слиянии возникают конфликты, тоесть иногда возникают проблемы, которые Git сам не может решить и для этого ему нужна ваша помощь.
 
## Слияние и конфликты

Наличие двух версий одного документа для Git не проблема, однако конфликт возникает тогда, когда есть два изменения в одной строке или наборах строк в двух разных коммитах, потому что тогда Git не может решить, какой из них использовать или как их объединить. Вот тогда появляются конфликты при слиянии.

* Создадим новый бранч и переключимся на него

```bash
git checkout -b text_edits
```

* Сделаем разные изменения в одних и тех же строках в разных бранчах и закоммитим их.
* После этого, если мы попробуем сделать слияние, то Git нам скажет, что есть конфликты и укажет в каких именно файлах они имеются.
* Нужно открыть данные файлы, подредактировать файлы и закоммитить результат. При этом на данный момент мы не будем находится полностью в основном бранче - мы будем находится в процессе слияния и Git сообщает нам об этом. Конфликтные строки Git помечает используя специальные символы.

```bash
git branch
git checkout master
git merge text_edits
```

## Решение конфликтов слияния

В предыдущем уроке мы сделали изменения в файле *index.html* после которых возник конфлик и теперь Git хочет чтобы мы решили этот конфликт перед тем как он сделает слияние бранчей. В этом уроке мы научимся решать такие конфликты.

Решить конфликты можно тремя способами:

* Во-первых можно просто оборвать слияние
* Решить конфликт в ручную. В большинстве случаев так и будет происходить, особенно в самом начале
* Можно использовать инструмент для слияния. Есть несколько инструментов, но к ним не стоит переходить до тех пор, пока вы вручную не научитесь этого делать.

Чтобы оборвать слияние всё что нужно написать это:

```bash
git merge --abort
```

Обратите внимание что теперь мы уже не находимся в состоянии `MERGING`.

Давайте снова попробуем сделать слияние чтобы снова получить конфликт.

```bash
git merge text_edits
```

Теперь нам нужно разрешить конфликт вручную и после этого сохранить изменения и закоммитить результат.

Нужно открыть файл в котором возник конфликт, в нашем случае это *index.html* и найти начала конфликта, котрый обозначается таким образом - `<<<<<<<`. Если бы было несколько конфликтов, то Git пометил бы их все.

Один конфликт мог бы возникнуть вверху документа, один в средине, а один в самом конце и каждый из них был бы отмечен, тоесть всегда будет проблема и вам нужно просмотреть этот документ чтобы найти все эти конфликты. Можно использовать поиск и строку поиска ввести ```<<<` чтобы найти все эти места.

Если вы откроете текстовый документ, то можно легко понять что обозначает конфликт

* В бранче `master`, на нём установлен указатель `HEAD`, он обозначается `<<<<<<< HEAD`
* `=======` - разделитель коммитов
* `>>>>>>> text_edits` - окончание коммита в бранче `text_edits`

Давайте разберёмя в чём именно заключается наш конфликт для этого:

* Просмотрим логи последних 3-х коммитов
* Копируем хэш последнего коммита и используем команду `git show` для того чтобы увидеть что именно произошло
* В текстовом редакторе делаем корректировку и убираем все служебные знаки - `<<<`, `===`, `>>>`.
* Просмотрели и проверили сделанные изменения и что теперь вы имеете корректную версию документа.

```bash
git log --oneline -3
git show b7080b3
```

После сделанных изменений мы можем проверить статус, добавить изменённый файлы в буфер и сделать коммит.

```bash
git status
git add index.html
```

Обычно мы всегда добавляем сообщение для коммита, но на самом деле это можно и не делать. Когда вы находитесь в середине процесса слияния, то Git покажет стандартное сообщение, которое он использует, тоесть нам можно просто указать `git commit` и будет использованно сообщение по умолчанию.

Теперь если мы введём команду:

```bash
git branch --merged
```

То мы увидим что мы произвели полное слияние со всех веток во основную ветку `master`.

Вы открываете файл в котором произошёл конфликт, находите проблемное место и исправляете ошибку. Делаете это для всех файлов, где возник конфликт. Если есть 20 файлов, где возник конфликт, то вы исправляете все 20. После чего вы добавляете все файлы в буфер и коммитите изменения и вот тогда произойдёт слияние и все конфликты при слиянии будут разрешенны.

Есть одна классная команда, которая отобразит все бранчи и то что в них произошло

```bash
git log --graph --oneline --all --decorate
```

Таким образом вы получаете графическое представление о бранчах и слияниях.

Также можно использовать инструмент для слияния и когда вы находитесь в процессе слияния и конфликт не был разрешён, то вы можете написать `git mergtool --tool=` а затем имя инструмента, который вы хотите использовать.

Можно просмотреть список всех инструментов вызвав команду

```bash
git mergetool
```

Вы можете выбрать тот который вам ближе. Его также можно добавить в файл `.gitconfig`.

Использование инструментов для слияния является более продвинутой практикой.

## Стратегии для уменьшения конфликтов слияния

* Не создавать длинные строки. Если строки будут более короткими вам будет легче установить проблемные места. В некоторых случаях, это позволит Git разрешать конфликты автоматически, так что вам не нужно будет заботится об этом.
* Делать маленькие точные коммиты. Если вы делаете одно изменения файла в одном месте, тогда сразу делать коммит и переходить к редактированию документа в другом месте. Если вы будет делать много изменений в файле в разных местах и только после этого делать коммит, тогда вы сами будете создавать конфликты, если будете так поступать.
* Будьте осторожны при редактировании пробелов, табуляции, пробелов и возвратов строк - не нужно вносить не принципиальные изменения. Например, у вас может возникнуть конфликт, если вы меняете 4 пробела на 8.
* Делайте слияние часто, если есть такая возможность, потому что каждый раз когда вы это делаете, тогда конфликтов будет меньше. Просто представьте что вместо того чтобы решать конфликты в 3-х файлах, вам прийдётся это делать в 50 файлах.
* По мере работы, следует отслеживать изменения в основном бранче. Имеется в виду, что если делать изменения в основном бранче, стоит вносить эти изменения в ваш текущий бранч, так чтобы этот бранч был синхронизирован с основным и чтобы различния в них были не большими. Таким образом, большинство изменений будут в основном бранче и поэтому у нас уменьшится количество конфликтов при слиянии. Этот процесс называется отслеживанием.