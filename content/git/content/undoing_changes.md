# Отмена изменений

Это могут быть изменения, которые могут быть в рабочей директории, изменения из буфера и изменения, которые были закомичены в репозиторий.

## Востановление состояния репозитория определённого коммита

Для этого нужно использовать команду `checkout` и передать хеш коммита.

```bash
git checkout 2f1101758784979
```

Можно вернуть состояние только отдельного файла на указанный коммит таким образом

```bash
git checkout 2f1101758784979 -- index.html
```

## Отмена изменений в рабочей директории

Не всегда представляется отменить сделанные изменения в редакторе, потому что после его закрытия история изменений затирается. Для того чтобы сделать отмену сделанных в рабочей директории можно воспользоватся командой `checkout`

```bash
git checkout index.html
```

В большинстве случаев это сработает, однако команда `checkout` служит для цели - она также используется для работы с ветками. Если вы обращаетесь к ветке, тогда команда будет работать с веткой, а если файл, тогда файл или папку. Считается хорошей практикой, когда мы не делаем чекаут бранча вставлять `--` за которым идёт название файла или папки. Такая команда говорит Git оставатся в текущем бранче.

```bash
git checkout -- index.html
```

Теперь если мы проверим статус, то мы увидим что произошёл откат изменений в рабочей директории.

## Отмена изменений в буфере

Когда вы добавляете несколько файлов в буфер для того чтобы в последствии закомитить изменения. Но бывает так что вы случайно добавили изменённые файлы, которые не хотели бы отправлять в данный коммит и теперь требуется убрать этот файл из буфера. В статусе Git даёт подсказку нам небольшую подсказку - следует использовать команду `reset`

```bash
git reset HEAD index.html
git status
```

Данной командой мы сбрасываем изменения в буфере.

## Отмена коммитов

Git генерирует HASH для всех данных, которые содержатся в коммите. Слепок всех изменений, также мета информация - всё это входит в алгоритм, который генерирует хэш. Если мы поменяем что-то из этой информации, тогда поменяется весь хэш - это часть встроенной безопасности и интеграции данных в Git, тоесть ничего не может быть измененно в истории. Контрольная сумма предпоследнего коммита используется в методанных (поле `parent`), поэтому этот и предыдущие коммиты изменять нельзя. Но последний коммит пока что ни на что не влияет, поэтому его мы все таки можем изменить - мы можем это сделать с помощью опции `--amend`.

Мы можем изменить уже существующий коммит

* Делаем изменения
* Добавляем их в буфер
* Снова коммитим изменения используя `--amend` и тот же самое название для коммита

```bash
git add index.html
git status
git commit --amend -m "Another test commit"
```

Таким образом наш последний коммит был изменён. Такой подход также можно использовать если вы хотите изменить сообщение в коммите.

```bash
git commit --amend -m "Another test message for commit"
```

Обратите внимание на то что каждый раз, когда мы вносим изменения, то изменяется контрольная сумма коммита.

Помните что у нас есть возможность редактировать только последний коммит, тот на который указывает `HEAD`

Мы знаем что сложно менять более старые коммиты, поскольку это идёт в разрез с интеграцией данных, что является важной чертой Git. Вместо этого если нам нужно внести изменения в более старые коммиты, то лучше всего сделать новые коммиты, которые отменяют то что было сделанно в более старых. Есть много способов сделать новые коммиты, которые отменяют сделанные изменения, один из которых заключается в том что мы можем вручную сделать изменения, а затем закомитить результат. Рассмотрим другой способ, которых немного быстрее.

Нам нужно скопировать всю или часть контрольной суммы и затем использовать эту информацию чтобы получить версию состояния нашего документа на момент того коммита. Изменённый файл попадает в буфер (это можно проверить проверив статус) и нам нужно будет снова закомитить изменения, если мы заходим вернуть изменения которые были в предыдущем коммите.

```bash
git checkout 2f1101758784979 -- index.html
git status
git branch
```

Как видим что Git нам сообщает что `HEAD` откреплён и находится на коммите с указанным хэшом.

Из этого состояния мы можем делать изменения, а потом коммитить их. После чего можем их сохранить в отдельную ветку/

```bash
git branch <new-branch-name> cd45d29
```

Таким образом мы можем возвращатся по истории проекта и вносить изменения из желаемого состояния проекта.

Мы можем закомитить изменения, но вместо этого мы можем вернутся к исходному состоянию и изучить другую команду, которая делает очень похожие вещи.

```bash
git reset HEAD index.html
git checkout -- index.html
```

## Отмена изменений с помощью revert

Git даёт нам полезную возможность, когда мы можем изменить коммита целиком и полностью - для этих целей нужно использовать команду `revert`. Команда `revert` возмёт все изменения которые были сделанны в последнем коммите и уберёт их.

Нам нужно взять часть ссылки на коммит (даже часть контрольной суммы будет уникальной), копируем и используем как показанно ниже.

```bash
git revert b809da02daacb
git status
```

Далее Git предложит нам отредактировать сообщение для коммита в текстовом редакторе указанном в настройках Git - по умолчанию это Vim. После сохранения и закрытия текстового редактора, снова запускается Git и делает коммит. Мы увидим, что после проверки статуса у нас не будет никаких изменений в буфере, при этом наш файл вернулся к предыдущему состоянию.

Если мы сделаем `git log`, то мы увидим что был сделан новый коммит, который отменил сделанные изменения.

Мы можем передать опцию `-an` и тогда коммит не будет сделан - изменения будут отправленны в буфер и оно будет дожидатся когда вы сами сделаете коммит.

`git revert` работает хорошо с простыми вещами. С более сложными изменениями - если в это время были сделанны более сложные изменения, если файлы перемещали или переименованы. Git в таком случае использует более сложный набор правил для работы с такими изменениями и в этом наборе правил присутствует то что мы используем для слияния (`merge`). Слияние - это более продвинутый приём о котором мы поговорим немного позже. Тоесть, если вам нужно сделать возврат чего сложного, тогда вам нужно будет делать слияние между текущим бранчем и новым набором изменений, который вы хотите с ним объеденить.

## Отмена нескольких коммитов

Данную возможность нужно использовать с максимальной осторожностью.

`git reset` позволяет нам обозначать на что должен указывать `HEAD`. Обычно мы просто разрешаем Git указать оператором `HEAD`, мы делаем коммит и Git перемещает `HEAD` чтобы он указывал на этот коммит, затем мы делаем другой коммит и он перемещает `HEAD` чтобы указать на этот коммит. А здесь же мы говорим Git, что мы хотим сами всё контролировать, мы хотим переместить `HEAD` в это место и вот теперь отсюда начнётся запись и теперь с этого места мы будем делать коммиты.

Есть три различные опции, которые помогают котролировать эту команду:

* `--soft` - перемещает указатель `HEAD` на конкретный коммит, но она не меняет буфер или рабочую директорию. Это самая безопасная опция.
* `--mixed` - представляет собой что-то среднее между `--soft` и `--hard` и она установленна по умолчанию. Эта опция перемещает `HEAD` на конкретный коммит, а также она меняет буфер, чтобы он соответствовал репозиторию, но при этом она не меняет рабочую директорию и таким образом буфер и репозиторий будут установленны на одну точку, а в рабочей директории будут все те изменения, которые мы сделали
* `--hard` - не только переместит указатель `HEAD` в репозиторий, но также сделает так что буфер и рабочая директория будут ему соответствовать. Это значит что все изменения, которые шли за данным коммитом будут удаленны полностью, поэтому эту опцию следует использовать с осторожностью.

Если мы используем `git reset`, тогда мы больше не увидим наших коммитов в логах.

### git reset --soft

* Скопируем последние несколько коммитов в текстовый редактор, так как мы их больше не увидим 
* Проверим что указатель `HEAD` находится на последнем коммит
* Копируем контрольную сумму с предыдущего коммита и вставляем после команды `git reset --soft`
* Снова проверим, где теперь находится наш указатель
* Проверив логи мы увидим что в истории последним в списке коммитов, находится тот, который мы указали в команде `reset`
* Проверив статус мы увидим что у нас есть изменённый файл, который находится в буфере и рабочей директории. Нет изменений как в репозитории, только те изменения, которые мы сделали с тех пор - это возвращённый файл
* Проверим какие изменения были сделанны. Видим что наши изменения всё ещё находятся в буфере и рабочей директории
* Теперь мы можем зафиксировать изменения или вернутся к прежней версии

```bash
cat ~ .git/refs/heads/master
git reset --soft b809da02daac
cat ~ .git/refs/heads/master
git log
git status
git diff --staged
git reset --soft 318306fe08fd22
git log
```

Как мы видим команда `git reset --soft` вообще ничего не удаляет - она просто перемещает `HEAD` на другой коммит, но вся наша работа поддерживается и в буфере и рабочей директории и мы ничего не потеряли.

### git reset --mixed

После данной команды буфер будет выглядеть также как репозиторий.

Как уже говорилось ранее, хорошей практикой, перед выполнением `git reset` будет копирование нескольких последних коммитов из логов в текстовый редактор, на случай того, если нам нужно будет вернутся в будущем с текущему состоянию.

Вот собственно, моя история тестовых коммитов

```bash
commit 318306fe08fd2215f6fccf75398aa6172aee0a92
Author: Vladimir Kamuz <v.kamuz@gmail.com>
Date:   Wed Jun 1 11:42:58 2016 +0300

    Revert "Add copyright paragraph"

    This reverts commit b809da02daacb7e29aead4446c21fe24361a9138.

commit b809da02daacb7e29aead4446c21fe24361a9138
Author: Vladimir Kamuz <v.kamuz@gmail.com>
Date:   Wed Jun 1 11:40:03 2016 +0300

    Add copyright paragraph

commit 58b9ff25e30b19c266258b2f205a4e115cc0de6a
Author: Vladimir Kamuz <v.kamuz@gmail.com>
Date:   Wed Jun 1 11:39:13 2016 +0300

    Add unordering list
```

Команда `git reset --mixed` это то же самое что `git reset`

```bash
git reset --mixed b809da02daacb7e29aead4
git status
git diff
git reset --mixed 318306fe08fd2
git status
```

Если вы видите примерно такое сообщение

```bash
Unstaged changes after reset:
M       index.html
```

Это то что Git говорит после того как что-то вынимает из буфера. Тоесть это команда сделала практически тоже самое что и `--soft`, единственное отличие в том как выглядит буфер. Изменения которые мы сделали никуда не исчезли - они просто находится в рабочей директории. 

### git reset --hard

При жёстком сбросе, наш буфер и рабочая директория полностью соответствует репозиторию - этот вариант подходит в том случае, если вы точно уверенны что проделанные изменения больше вам не понадобятся и вы хотите вернутся к состоянию определённого коммита.

```bash
git reset --hard b809da02daacb7e
git log
git status
```

После проверки статуса мы видим что нет никаких изменений ни в буфере ни в рабочей директории, которые  мы могли бы закомитить. На самом деле Git не удаляет более поздние коммиты, он просто делает коммит за нас выбранного нами состояния нашего проекта. Все затёрные коммиты на самом деле можно востановить.

```bash
git reset --hard 318306fe08fd2215f
```

Удаление раз и навсегда последнего коммита

```bash
$ git reset --hard HEAD~1
```

## Удаление неотслеживаемых файлов из рабочей директории

Это можно сделать вручную, но ещё проще это сделать с помощью Git. Для этих целей используется команда `git clean`. Но сама по себе эта команда ничего не делает, чтобы это исправить ей нужно передать одну из двух опций

* `-n` - тестовый запуск, Git просто скажет какие файлы он готов удалить
* `-f` - сделает удаление

Давайте проверим это всё на практике

* Создадим несколько теcтовых файлов
* Вызываем команду `clear` с разными опциями

```bash
git status
git clean -n
git clean -f
git status
```

Если бы мы добавили какой-то файл в буфер, то он не будет удалён.