# Оператор выборки SELECT

Язык можно разделить на 3 группы запросов:

* Манипулирования данными - вставка, обновление и удаление данных
* Определения данных -  создание таблиц
* Выборка данных - операторы получение данных

В начале наполним БД данных. Вставим несколько новый клиентов.

```
INSERT INTO `customers` (`cnum`, `cname`, `city`, `rating`, `snum`) VALUES
(2001, 'Hoffman', 'London', 100, 1001),
(2002, 'Giovanni', 'Rome', 200, 1003),
(2003, 'Liu', 'San Jose', 200, 1002),
(2004, 'Grass', 'Berlin', 300, 1002),
(2006, 'Clemens', 'London', 100, 1001),
(2008, 'Cisneros', 'San Jose', 300, 1007),
(2007, 'Pereira', 'Rome', 100, 1004),
(2010, 'Dickens', 'LA', NULL, 1001);
```

Теперь несколько продавцов.

```
INSERT INTO `orders` (`onum`, `amt`, `odate`, `cnum`, `snum`) VALUES
(3001, 18.69, '1990-03-10', 2008, 1007),
(3003, 767.19, '1990-03-10', 2001, 1001),
(3002, 1900.10, '1990-03-10', 2007, 1004),
(3005, 5160.45, '1990-03-10', 2003, 1002),
(3006, 1098.16, '1990-03-10', 2008, 1007),
(3009, 1713.23, '1990-04-10', 2002, 1003),
(3007, 75.75, '1990-04-10', 2004, 1002),
(3008, 4723.00, '1990-05-10', 2006, 1001),
(3010, 1309.95, '1990-06-10', 2004, 1002),
(3011, 9891.88, '1990-06-10', 2006, 1001);
```

И создадим несколько заказов.

```
INSERT INTO `salers` (`snum`, `sname`, `city`, `comm`) VALUES
(1001, 'Peel', 'London', 0.12),
(1002, 'Serres', 'San Jose', 0.13),
(1004, 'Motika', 'London', 0.11),
(1007, 'Rifkin', 'Barcelona', 0.15),
(1003, 'Axelrod', 'New York', 0.10);
```

Более правильно будет указывать команды в верхнем регистре, а имена таблиц, полей указывать в обратных кавычках, но при этом если даже не придерживаться данных правил запросы всё равно будут отлично работать.

Все имена таблиц и полей рекомендуется указывать в нижнем регистре.

Можно выбрать все данные из таблицы.

```
SELECT * FROM orders;
```

А можно только отдельные поля.

```
SELECT amt, cnum FROM orders;
```

Можно выбрать все данные из таблицы при этом переопределить порядок полей по умолчанию. Такой вариант работает шустрее.

```
SELECT amt, onum, cnum, odate, snum FROM orders;
```

Каждое дополнительное поле во время выборки, которое в результате нигде не используется влияет на время обработки запроса.

Аргумент `DISTINCT` позволяет получить значение полей в единичном экземпляре, таким образом удаляются дубли с одинаковыми значениями.

```
SELECT DISTINCT odate FROM orders;
```

`WHERE` задаёт условие выборки. По сути это является своеобразным фильтром.

```
SELECT odate, amt FROM orders WHERE odate = '1990-04-10';
```

Условие для рейтинга.

```
SELECT cname, city FROM customers WHERE rating = 200;
```

Для того чтобы вставить или отобразить из консоли кирилические значения нам необходимо для консоли назначить правильную кодировку.

```
SET NAMES cp866;
```

Возвратим строки где продавцы не работают в Лондоне.

```
SELECT * FROM salers WHERE city != 'London';
```

Также можно сравнивать строки, но это плохая практика.

```
SELECT * FROM salers WHERE sname > 'Rifkin';
```

Чтобы понять, почему именно так нужно отсортировать по строковому полю, где также есть сравнение символов (0-9A-Za-zА-Яа-я).

```
SELECT * FROM salers ORDER BY sname;
```

Логические выражения позволяют задать несколько условий. `AND` возвратит `TRUE` если оба выражения будут `TRUE`.

```
SELECT * FROM salers WHERE city = 'London' AND comm > 0.11;
```

`OR` вернёт `TRUE` если хотя бы одно выражение возвращает `TRUE`.

```
SELECT * FROM salers WHERE city = 'London' OR comm > 0.11;
```

`NOT` делает инверсию результата.

```
SELECT * FROM customers WHERE NOT city = 'London';
```

Достаточно запутанный запрос, но здесь важно учитывать приоритет операторов (скобки) для того чтобы разобратся в том что мы должны получить.

```
SELECT * FROM orders WHERE NOT((odate = '1990-03-10' AND snum > 1002) OR amt > 2000.00);
```